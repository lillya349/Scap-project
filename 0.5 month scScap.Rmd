---
title: "0.5 month scScap"
author: "Anna Lilly"
date: "2025-07-28"
output: html_document
---
# Processing and Analysis of Tumor Data

**Sample Information**


```{r setup, include=FALSE}
library(Seurat)
library(ggplot2)
library(patchwork)
library(SoupX)

library(dplyr)
library(stringr)
library(RColorBrewer)
library(pheatmap)
library(magrittr)
library(fgsea)
library(msigdbr)
library(data.table)
library(org.Mm.eg.db)
library(paletteer)
library(fishualize)
set.seed(349)
```

### SoupX
```{r}
correct_reads <- function(data_dir, rho = NULL , extra = NULL, cap = FALSE){
  # correct_reads <- function(data_dir, extra = NULL, cap = FALSE){
  
  
  # importing libraries
  library(Seurat)
  library(SoupX)
  library(dplyr)
  library(tidyr)
  
  # importing dataset
  sc = load10X(data_dir, verbose = F)
  
  # Creating seurat clusters
  seurat_obj <- Read10X(paste0(data_dir,"/filtered_feature_bc_matrix/"))
  seurat_obj <- CreateSeuratObject(seurat_obj)
  seurat_obj <- FindVariableFeatures(seurat_obj, selection.method = "vst", nfeatures = 2000, verbose = FALSE)
  seurat_obj <- NormalizeData(seurat_obj, verbose = FALSE)
  seurat_obj <- ScaleData(seurat_obj, verbose = FALSE)
  seurat_obj <- RunPCA(seurat_obj, features = VariableFeatures(seurat_obj), verbose = FALSE)
  seurat_obj <- FindNeighbors(seurat_obj, dims = 1:30, verbose = FALSE)
  seurat_obj <- FindClusters(seurat_obj, resolution = 0.5, verbose = FALSE)
  seurat_obj <- RunUMAP(seurat_obj, dims = 1:30, verbose = FALSE)
  
  # addin clusters and DR to soupx object
  clusters <- data.frame("clusters" = seurat_obj$seurat_clusters, row.names = colnames(seurat_obj))
  umap <- as.data.frame(seurat_obj@reductions$umap@cell.embeddings)
  sc = setClusters(sc, setNames(clusters$clusters, rownames(clusters)))
  sc = setDR(sc, umap)
  
  if (missing(rho)){
    
    #Mouse
    acinar_markers <- c('Ctrb1','Klk1','Rbpjl','Ptf1a','Cela3a','Prss1','Spink1','Zg16','Cel','Cela2a','Cpb1','Cela1','Rnase1','Amy2b','Cpa2','Cpa1','Cela3b','Pnlip','Ctrb2','Pla2g1b','Prss2','Clps','Reg1a','Sycn','Pnliprp1','Ctrc','Reg3a','Serpina3','Prss3','Reg1b','Cfb','Gdf15','Muc1','C15orf48','Duoxa2','Akr1c3','Olfm4','Gsta1','Lgals2','Pdzk1ip1','Rarres2','Cxcl17','Ubd','Gsta2','Anpep','Lyz','Angptl4','Aldob')
    acinar_markers <- acinar_markers[acinar_markers %in% row.names(sc$toc)]
    rbc_markers <- c('Hexa','Aqp1','Ccna2','Pklr','Lox','Arg1','Hbb','Hba-a1','Hba-a2','Hbb-bh1','Ceacam1','Cd36','Gypa','Thbs1','Itga4','Ahsp','Fech','Epor','Kit','Bpgm','Dcaf12','Hemgn','Hmbs','Ncoa4','Rbm38','Ucp2','Ubb','Tmcc2','Slc4a1','Slc25a39','Slc25a37','Fosb','Htatsf1','Epb41','Rsad2','Cox6b2','Apoa1','Asns','Alad','S100a9','Ahsg','S100a8','Ermap','Kcnn4','Pan3','Pfas','Vamp5','Pnpo')
    rbc_markers <- rbc_markers[rbc_markers %in% row.names(sc$toc)]
    beta_markers <- c('Gcgr','Jph3','Cd40','Hamp','Ezh1','Ntrk1','Pdx1','Slc2a2','Nkx6-2','Fxyd2','Npy','Ins1','Rims1','Mafa','Efna5','Lmx1a','Nkx2-2','Nkx6-1','Pax4','Iapp','Pcsk2','G6pc2','Slc30a8','Pcsk1','Gjd2','Scgn','Igf2','Syt13','Ffar2','Nptx2','Pfkfb2','Edaradd','HOPX','Sh3gl2','Adcyap1','Scgb2a1','Casr','Mafb','Pax6','Neurod1','Isl1','Tgfbr3','Smad9','Six3','Six2','Bmp5','Pir','Stxbp5','Dlk1','Meg3','Rgs16')
    beta_markers <- beta_markers[beta_markers %in% row.names(sc$toc)]
    
    nonExpressedGeneList = list(acinar_markers  = acinar_markers,
                                rbc_markers = rbc_markers,
                                beta_markers = beta_markers)
    
    useToEst = estimateNonExpressingCells(sc, nonExpressedGeneList = nonExpressedGeneList)
    
    sc = calculateContaminationFraction(sc, nonExpressedGeneList = nonExpressedGeneList, useToEst = useToEst)
    print(paste0("The estimated contamination fraction is: ", round(sc$metaData$rho[1],3)))
    
    if (missing(extra)){
      
      note = "no extra value was added to the contamination fraction as it wasn't provided"
      if (cap){
        new_rho = min(sc$metaData$rho[1],0.2)
        sc = setContaminationFraction(sc, new_rho)
        out = adjustCounts(sc, roundToInt = T, verbose = F)
      } else {out = adjustCounts(sc, roundToInt = T, verbose = F)}
      
    } else {
      
      new_rho = sc$metaData$rho[1]+extra
      note = "added extra 10% to the contamination fraction as provided"
      if (cap){
        new_rho = min(new_rho,0.2)
        sc = setContaminationFraction(sc, new_rho)
        out = adjustCounts(sc, roundToInt = T, verbose = F) 
      } else {
        sc = setContaminationFraction(sc, new_rho, forceAccept = T)
        out = adjustCounts(sc, roundToInt = T, verbose = F) 
      }
    }
    
    # if (sc$metaData$rho[1] > 0.2) {
    #   note = "no extra value was added to the contamination fraction, Contamination fraction is already high (> 20%)"
    #   new_rho = min(sc$metaData$rho[1],0.2)
    #   sc = setContaminationFraction(sc, new_rho)
    #   out = adjustCounts(sc, roundToInt = T, verbose = F)
    
    # } else {
    # print(paste0("Adding ",extra," to the estimated fraction"))
    # new_rho = sc$metaData$rho[1]+extra
    # sc = setContaminationFraction(sc, new_rho)
    # note = "added extra 10% to the contamination fraction as provided"
    # out = adjustCounts(sc, roundToInt = T, verbose = F)
    # }
    
    
  } else {
    
    sc = setContaminationFraction(sc, rho)
    out = adjustCounts(sc, roundToInt = T, verbose = F)
    note = "Contamination Fraction was provided by the user"
    
  }
  
  TopContGenes <- data.frame("Genes" = row.names(sc$soupProfile),
                             "counts" = sc$soupProfile$counts,
                             "fraction" = sc$soupProfile$est)
  
  Misc(seurat_obj, "TopContGenes") <- TopContGenes[order(TopContGenes$counts, decreasing = T),]
  Misc(seurat_obj, "ContaminationFraction") <- round(sc$metaData$rho[1],3)
  Misc(seurat_obj, "notes") <- note
  
  seurat_obj[['CorrectedCounts']] <- CreateAssayObject(counts = out)
  DefaultAssay(seurat_obj) <- 'CorrectedCounts'
  
  print(paste0("Returning seurat object with new default assay (CorrectedCounts) and top contaminating genes in Misc slot"))
  
  return(seurat_obj)
}
```

### Run Correct_reads function with Scap samples
```{r}
setwd()
# Results WT - Global contamination fraction of 5.02% 
Obj1 <- correct_reads("cellranger_pipeline_outputs/WT/outs", extra = 0.1, cap = T)
# Results KO - Global contamination fraction of 3.56%
Obj2 <- correct_reads("cellranger_pipeline_outputs/KO/outs", extra = 0.1, cap = T)
```

### Add Metadata
```{r}
Obj1[["Group"]] <- "Wildtype"
Obj2[["Group"]] <- "Knockout"
Obj1[["Run_Date"]] <- "July 2023"
Obj2[["Run_Date"]] <- "July 2023"
Obj1[["Sample"]] <- "wildtype_pancreas"
Obj2[["Sample"]] <- "knockout_pancreas"
```


### Merge Data
Add in all the individual samples and give them each a cell ID <br>
The cell IDs aren't super important for after this step, but they are required to run this line of code
```{r}
obj <- merge(x = Obj1, y = c(Obj2),add.cell.ids = (c("Obj1","Obj2")))
```

### Make SoupX Corrected Counts Compatible with Seurat5

```{r}
obj@assays[["CorrectedCounts"]] <- as(object = obj@assays[["CorrectedCounts"]], Class = "Assay5")
rm(Obj1, Obj2, correct_reads)
```

## Normalize Data
### Log Normalize
```{r}
obj <- NormalizeData(object = obj, normalization.method = "LogNormalize", scale.factor = 10000)
```


### Apply Unbiased QC Cutoffs
```{r}
obj[["percent.mt"]] <- PercentageFeatureSet(object = obj, pattern = "^mt")
Idents(obj) <- "Group"
VlnPlot(obj, features = c("percent.mt", "nCount_RNA", "nFeature_RNA"), split.by = "Sample", split.plot = TRUE)
VlnPlot(obj, features = c("percent.mt", "nCount_RNA", "nFeature_RNA"), pt.size = 0, log = T)
```

### Filter Out Low Quality Reads
Filter out low quality cells: <800 reads and >15% mitochondrial genes <br> 
Filter out doublets: >10,000 reads 
```{r}
obj <- subset(x = obj, subset = nCount_RNA > 800 & nCount_RNA < 100000 & percent.mt < 15)
VlnPlot(obj, features = c("percent.mt", "nCount_RNA", "nFeature_RNA"))
```


## Identify Outlier features/genes
```{r}
obj <- FindVariableFeatures(obj, selection.method = "vst", nfeatures = 2000) 
```

## Scale data and run principal component analysis (PCA)  dimensionality reduction
```{r}
all.genes <- rownames(obj)
obj <- ScaleData(obj, verbose = T, features = all.genes)
obj <- RunPCA(obj, npcs = 30, verbose = FALSE)
rm(all.genes)
```


## Integration 
Integration is not necessary because samples were sequenced at the same time <br>
Try without and if samples are clustering together, it should be fine to not integrate

## Calculate Principal Components
"Each PC represents a 'metagene' that combines information across a correlated gene set." <br>
Determine the number of dimensions for dimensionality reduction is by calculating the number of dimentions where the PCs contribute to 90% of the standard deviation. 
```{r}
st_dev <- obj@reductions$pca@stdev
var <- st_dev^2
sum(var[1:18])/ sum(var) #change x (1:x) until you get as close to 0.9 as possible
# Changes to 1:18. Results in 0.902 or 90.2%
rm(st_dev, var)
```


## Clustering
Seurat graphs each cell based on gene expression patter (cells with the most similar expression are clostest together). <br>
The higher the resolution is, the most clusters there will be. The lower the resolution, the fewer. 
```{r}
obj <- FindNeighbors(object = obj, dims = 1:18) #same as PCs calculated
obj <- FindClusters(object = obj, resolution = 0.2)
```


## Dimensional Reduction
```{r}
Idents(obj) <- "seurat_clusters"
obj <- RunUMAP(obj, reduction = "pca", dims = 1:18, verbose = F) # or1:20
DimPlot(obj, reduction = "umap", label = T)
DimPlot(obj, reduction = "umap", label = T, split.by = "Sample")
```

##rejoin layers - must do before doing DE
```{r}
obj <- JoinLayers(obj)
```

### Unknown Clusters
Sort by avg_log_FC high to low
```{r}
Cluster0 <- FindMarkers(obj, ident.1 = "0", only.pos = T)
Cluster1 <- FindMarkers(obj, ident.1 = "1", only.pos = T)
Cluster2 <- FindMarkers(obj, ident.1 = "2", only.pos = T)
Cluster3 <- FindMarkers(obj, ident.1 = "3", only.pos = T)
Cluster4 <- FindMarkers(obj, ident.1 = "4", only.pos = T)
Cluster5 <- FindMarkers(obj, ident.1 = "5", only.pos = T)
Cluster6 <- FindMarkers(obj, ident.1 = "6", only.pos = T)
Cluster7 <- FindMarkers(obj, ident.1 = "7", only.pos = T)
Cluster8 <- FindMarkers(obj, ident.1 = "8", only.pos = T)
Cluster9 <- FindMarkers(obj, ident.1 = "9", only.pos = T)
Cluster10 <- FindMarkers(obj, ident.1 = "10", only.pos = T)
Cluster11 <- FindMarkers(obj, ident.1 = "11", only.pos = T)
Cluster12 <- FindMarkers(obj, ident.1 = "12")
Cluster13 <- FindMarkers(obj, ident.1 = "13", only.pos = T)
Cluster14 <- FindMarkers(obj, ident.1 = "14", only.pos = T)
Cluster15 <- FindMarkers(obj, ident.1 = "15", only.pos = T)
```

## Label Manual Clusters with cell type
```{r}
 Idents(obj) <- "seurat_clusters"
obj <- RenameIdents(obj, 
                    "8" = "Exocrine cells", #pancreatic epithelial
                    "4" = "Acinar", #pancreatic epithelial
                    "0" = "Mesenchymal", 
                    "11" = "Stellate",
                    "6" = "Proliferative Mesenchymal", 
                    "7" = "Mesothelial", 
                    "1" = "Immune", 
                    "2" = "Immune", 
                    "12" = "Immune",
                    "3" = "Mesenchymal", 
                     "10" = "Immune", 
                    "9" = "Endothelial cells", 
                    "13" = "Immune",
                    "15" = "Mesenchymal",
                    "14" = "Schwann cell",
                      "5" = "RBCs")
#This give your clusters a name that you can switch between using ' Idents(obj) <- "manual_clusters"
obj[["manual_clusters"]] <- obj@active.ident

```


### count number of cells per cluster (https://www.biostars.org/p/399234/)
```{r}
#get information for celltype
library(data.table)
library(magrittr)

## extract meta data - the resulting md object has one "row" per cell
md <- obj@meta.data %>% as.data.table

##count the number of cells per unique combination of "Sample" and "seurat_clusters"
md[, .N, by = c("Sample", "manual_clusters")]

##with additional casting after the counting
plot <- md[, .N, by = c("Sample", "manual_clusters")] %>% dcast(., Sample ~ manual_clusters, value.var = "N")
rm(plot, md)
```

### Visualize new labels
```{r}
Idents(obj) <- "manual_clusters"
DimPlot(obj, reduction = "umap")
umap <- DimPlot(obj, reduction = "umap", cols = "Paired")
umap <- DimPlot(obj, reduction = "umap",split.by = "Group", cols = "Paired")
```

#heatmap for cell type 
```{r}
cell_types <- c("Cdh1", "Epcam", "Rbpjl", "Sox9", "Muc1", "Pkhd1", "Erbb4", "Krt19", "Msln", "Cpa1", "Cela2a", "Cpa2", "Cpb1", "Pnliprp1","Pnlip", "Ins1", "Ins2", "Fbn1", "Fndc1", "Col3a1", "Col1a1", "Fn1", "S100a11", "Pdgfra", "Acta2", "Mki67", "Ptprc", "Fyb", "Cd4", "Cd19", "Dock10", "Nrros", "Pecam1", "Ncam1", "Hba-a1",  "Plin1", "Plin4")
heatmap_2w <- DoHeatmap(obj, cell_types, label = F)+scale_fill_gradient2(low = "#333DBF",
  mid = "white",
  high = "#D22828")

DotPlot(obj, features = cell_types, cols = c("RdBu"), dot.scale = 8) + RotatedAxis()

acinar_types <- c("Rbpjl", "Chrm3", "Insr", "Foxp2", "Chn2", "Dtna", "Sdk1", "Reg3a", "Reg3g", "Reg3b", "Cpb1", "Cpa1", "Prss3", "Prss1", "Cela2b", "Cela3a", "Cela3b", "Sycn", "Pnlip", "Spink1", "Cpa2", "Ctrc", "Bicc1", "Cftr", "Slc4a4")
DotPlot(obj, features = acinar_types, cols = c("RdBu"), dot.scale = 8) + RotatedAxis()
```

# Functions
```{r}
## Add Ensemble IDs to DEA information
### tsv = filtered features.tsv.gz for a sample in the study
add_ensembl <- function(df, tsv, folder, fn){
  genes <- read.table(tsv, stringsAsFactors = FALSE)
  genes$V2 <- make.unique(genes$V2)
  write.csv(df, paste(folder, fn,".csv"))
  t1 <- tibble::rownames_to_column(df, "V2")
  t2 <- inner_join(t1, genes, by = join_by(V2))
  write.csv(t2, paste(folder,"with ensemble/",fn,"_test.csv", sep=""))
  return(t2)
}

## Add GSEA rank information
rank <- function(df, folder, fn){
  rank_table = sign(df$avg_log2FC)*-log10(df$p_val_adj)
  ranked <- cbind(df, rank_table)
  write.csv(ranked, paste(folder,"GSEArank/",fn,"_ranked.csv", sep=""))
  return(ranked)
}

# Make GSEA file
GSEArank <- function(f1, folder, fn){
  df <- read.csv(f1)
  dfGSEA <- subset(df, select = c(V1, rank_table))
  colnames(dfGSEA) <- c("genenames", "Rank")
  return(dfGSEA)
  write.table(dfGSEA, file.path(folder, paste(fn, "rank.rnk", sep = "")), 
              col.names = FALSE, sep = "\t", row.names = FALSE, quote = FALSE)
}

```

##Example of running functions
###Mesenchymal
```{r}
Mesenchymal.only <- subset(obj, idents = "Mesenchymal")
Idents(Mesenchymal.only) <- "Group"
fn = "Mesenchymal"
Idents(Mesenchymal.only) <- "Group"
MesenchymalDE <- FindMarkers(Mesenchymal.only, ident.1 = "Knockout", ident.2 = "Wildtype", ogfc.threshold = -Inf, min.pct = -Inf, min.diff.pct = -Inf)
Mesenchymal_En <- add_ensembl(MesenchymalDE, tsv, folder, fn)
Idents(Mesenchymal.only) <- "manual_clusters"
VlnPlot(Mesenchymal.only, features = c("Kitl", "Kit", "Lepr"), cols = c("#D22828", "#333DBF"), pt.size = 0, split.by = "Group", split.plot = T, log = T)
VlnPlot(Mesenchymal.only, features = c("Pdgfra", "Fap", "Vim", "Il6"), cols = c("#D22828", "#333DBF"), pt.size = 0, split.by = "Group", split.plot = T, log = T)

```
